import numpy as np


class PIDcontroller:

  def __init__(self, Kp, Ki, Kd):
    self.Kp = Kp
    self.Ki = Ki
    self.Kd = Kd
    self.target = None
    self.I = np.array([0.0, 0.0, 0.0])
    self.lastError = np.array([0.0, 0.0, 0.0])
    self.timestep = 0.1
    self.maximumValue = 0.1

  def setTarget(self, targetx, targety, targetw):
    """
        set the target pose.
        """
    self.I = np.array([0.0, 0.0, 0.0])
    self.lastError = np.array([0.0, 0.0, 0.0])
    self.target = np.array([targetx, targety, targetw])

  def setTarget(self, state):
    """
        set the target pose.
        """
    self.I = np.array([0.0, 0.0, 0.0])
    self.lastError = np.array([0.0, 0.0, 0.0])
    self.target = np.array(state)

  def getError(self, currentState, targetState):
    """
        return the different between two states
        """
    result = targetState - currentState
    result[2] = (result[2] + np.pi) % (2 * np.pi) - np.pi
    return result

  def setMaximumUpdate(self, mv):
    """
        set maximum velocity for stability.
        """
    self.maximumValue = mv

  def update(self, currentState):
    """
        calculate the update value on the state based on the error between current state and target state with PID.
        """
    e = self.getError(currentState, self.target)

    P = self.Kp * e
    self.I = self.I + self.Ki * e * self.timestep
    I = self.I
    D = self.Kd * (e - self.lastError)
    result = P + I + D

    self.lastError = e

    # scale down the twist if its norm is more than the maximum value.
    resultNorm = np.linalg.norm(result)
    if (resultNorm > self.maximumValue):
      result = (result / resultNorm) * self.maximumValue
      self.I = 0.0

    return result
